import logging
import json
import os
import asyncio
import pytz 
from datetime import datetime, time, timedelta

#=================
# TGBot_2.5 å¸¶å½©è›‹ Dec/18/2025
# åŸºæœ¬åŠŸèƒ½æ²’å•é¡Œ è³‡ç”¢å·²ç¶“ä¿®æ”¹å¥½ ä¸¦åŠ äº†æ¬Šé‡åŠŸèƒ½
# ç­‰å¾…ç™¼æ˜æ›´å¤šåŠŸèƒ½
#=================

# æ•¸æ“šèˆ‡è¨ˆç®—åº«
import yfinance as yf
import pandas as pd
import numpy as np
from itertools import groupby

# Telegram Bot åº« (v20+): æ–°å¢ MessageHandler å’Œ filters
from telegram import Update
from telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler, JobQueue, MessageHandler, filters 

# é…ç½®æ—¥èªŒï¼šç¢ºä¿æ‰€æœ‰è¼¸å‡ºéƒ½ä½¿ç”¨æ¨™æº–æ—¥èªŒç³»çµ±
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

# ================= é…ç½®å€åŸŸ =================

# 1. Telegram è¨­å®š
TG_BOT_TOKEN = '8074680946:AAFshgFINNVlVYJFl88-E9z_o8Zj-KsfRSs' 

# 2. æ¯æ—¥è‡ªå‹•æ¨é€æ™‚é–“ (UTCæ™‚é–“)
DAILY_REPORT_TIME = time(hour=21, minute=30, tzinfo=pytz.utc)

# ==========================================
# 3. è§€å¯Ÿæ¸…å–®èˆ‡è³‡é‡‘æ¬Šé‡é…ç½® (RunSing Capital 15)
# ==========================================

# æœ€çµ‚ç²¾é¸çš„ 15 æ”¯è³‡ç”¢åˆ—è¡¨
TICKERS = [
    # --- ç¬¬ä¸€æ¢¯éšŠï¼šæ ¸å¿ƒé‡ç‚® (Core) | æ¬Šé‡ 3 ---
    'GOOGL', 'NVDA', 'LLY', 'WMT', 'AVGO',

    # --- ç¬¬äºŒæ¢¯éšŠï¼šä¸­å …åŠ›é‡ (Standard) | æ¬Šé‡ 2 ---
    'META', 'COST', 'CAT', 'QQQ', 'AAPL',

    # --- ç¬¬ä¸‰æ¢¯éšŠï¼šé«˜çˆ†ç™¼/é¢¨æ§ (Aggressive) | æ¬Šé‡ 1 ---
    'TQQQ', 'TSLA', 'TSM', 'MSTR', 'IBIT'
]

# è³‡é‡‘æ¬Šé‡æ˜ å°„ (1:2:3 ç­–ç•¥)
# ç”¨æ–¼è¨ˆç®—å–®æ¬¡è²·å…¥ä»½æ•¸ï¼šåŸºç¤å–®ä½ x æ¬Šé‡
# ä¾‹å¦‚ï¼šåŸºç¤å–®ä½ $50 -> æ¬Šé‡3 = $150, æ¬Šé‡1 = $50
BUY_WEIGHTS = {
    # Core (3ä»½) - ä¿¡è™Ÿå°‘ï¼Œå–®æ¬¡è²·å¤š
    'GOOGL': 3, 'NVDA': 3, 'LLY': 3, 'WMT': 3, 'AVGO': 3,
    
    # Standard (2ä»½) - æ¨™æº–é…ç½®
    'META': 2, 'COST': 2, 'CAT': 2, 'QQQ': 2, 'AAPL': 2,
    
    # Aggressive (1ä»½) - ä¿¡è™Ÿå¤šï¼Œå–®æ¬¡è²·å°‘ (é¢¨æ§)
    'TQQQ': 1, 'TSLA': 1, 'TSM': 1, 'MSTR': 1, 'IBIT': 1
}

# ------------------------------------------
# 4. ç­–ç•¥åƒæ•¸
N1 = 9; N2 = 12
LEVEL_1_BUY = -35
LEVEL_2_BUY = -60
LOOKBACK_DAYS = 7
USER_DATA_FILE = "users.json"

# 5. æ¿«ç”¨é™åˆ¶åƒæ•¸
SCAN_COOLDOWN_SECONDS = 120 # æ¯å€‹ç”¨æˆ¶ç™¼èµ·æƒæçš„é–“éš”æ™‚é–“ (ç§’)

# 6. å½©è›‹é…ç½® (æ–°å¢)
# ä½¿ç”¨ä¸€å€‹å…¬é–‹çš„ç¶­å°¼æ’ç•« URL
WINNIE_POOH_URL = "https://i.ibb.co/DDDVRp2r/IMG-5226.jpg"


# ================= å…¨å±€è¿½è¹¤è®Šæ•¸ =================
LAST_SCAN_TIME = {} # ç”¨æˆ¶ID: ä¸Šæ¬¡æƒææ™‚é–“ (datetime object)

# ================= åŠ©æ‰‹åŠŸèƒ½ =================

def log_command(update: Update, command: str):
    """å°‡æ¥æ”¶åˆ°çš„æŒ‡ä»¤å’Œç”¨æˆ¶è³‡è¨Šå¯«å…¥æ—¥èªŒ (ç”¨æ–¼è¿½è¹¤å’Œç®¡ç†)"""
    user = update.effective_user
    chat = update.effective_chat
    
    # ç¢ºä¿ç”¨æˆ¶åå­˜åœ¨ï¼Œå¦å‰‡ä½¿ç”¨å…¨å
    username = f"@{user.username}" if user.username else user.full_name
    
    user_info = f"UID:{chat.id} | User: {username}"
    logging.info(f"[COMMAND] {command:<10} received from {user_info}") # å°‡ :<6 æ”¹ç‚º :<10 è®“æ—¥èªŒå°é½Š

def load_users():
    """å¾ JSON è¼‰å…¥è¨‚é–±ç”¨æˆ¶"""
    if not os.path.exists(USER_DATA_FILE): return set()
    try:
        with open(USER_DATA_FILE, 'r') as f:
            return set(json.load(f))
    except json.JSONDecodeError:
        return set()

def save_users(users):
    """å°‡è¨‚é–±ç”¨æˆ¶å„²å­˜åˆ° JSON"""
    with open(USER_DATA_FILE, 'w') as f:
        json.dump(list(users), f)

# ================= æ ¸å¿ƒæƒæé‚è¼¯ =================

def calculate_mcb(df, n1=9, n2=12):
    """è¨ˆç®— MCB æŒ‡æ¨™"""
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.get_level_values(0)
    source = (df['High'] + df['Low'] + df['Close']) / 3
    # å¿…é ˆæ˜¯å¤§å¯« F
    esa = source.ewm(span=n1, adjust=False).mean() 
    d = (source - esa).abs().ewm(span=n1, adjust=False).mean()
    ci = (source - esa) / (0.015 * d.replace(0, 0.00001))
    
    # å¿…é ˆæ˜¯å¤§å¯« F
    wt1 = ci.ewm(span=n2, adjust=False).mean() 
    
    wt2 = wt1.rolling(window=3).mean()
    df['wt1'] = wt1; df['wt2'] = wt2
    return df

def run_scan_logic():
    """åŸ·è¡Œæ‰€æœ‰æ¨™çš„æƒæä¸¦è¿”å›å ±å‘Šæ–‡æœ¬"""
    all_signals = []
    
    logging.info(f"[{datetime.now().strftime('%H:%M:%S')}] é–‹å§‹åŸ·è¡Œæƒæä»»å‹™...")
    
    total_tickers = len(TICKERS) 
    
    for idx, ticker in enumerate(TICKERS, 1):
        try:
            df = yf.download(ticker, period="6mo", interval="1d", progress=False, auto_adjust=False)
            
            if len(df) < 50: 
                logging.warning(f"[{idx}/{total_tickers}] æƒæ {ticker}: æ•¸æ“šä¸è¶³ï¼Œè·³éã€‚")
                continue
                
            df = calculate_mcb(df, N1, N2)
            check_range = df.iloc[-(LOOKBACK_DAYS + 1):]
            
            signal_found = False
            
            for i in range(1, len(check_range)):
                curr_row = check_range.iloc[i]
                prev_row = check_range.iloc[i-1]
                crossover = (prev_row['wt1'] < prev_row['wt2']) and (curr_row['wt1'] >= curr_row['wt2'])
                
                if crossover:
                    val = curr_row['wt1']
                    action_str = ""
                    if val < LEVEL_2_BUY: action_str = "2Ã— Buy"
                    elif val < LEVEL_1_BUY: action_str = "1Ã— Buy"
                    
                    if action_str:
                        all_signals.append({
                            'ticker': ticker,
                            'date': curr_row.name.strftime('%Y-%m-%d'),
                            'price': curr_row['Close'],
                            'mcb_val': val,
                            'action': action_str
                        })
                        signal_found = True
            
            if signal_found:
                 logging.info(f"[{idx}/{total_tickers}] æƒæ {ticker}: âœ… ç™¼ç¾ä¿¡è™Ÿã€‚")
            else:
                 logging.info(f"[{idx}/{total_tickers}] æƒæ {ticker}: ç„¡ä¿¡è™Ÿã€‚")

        except Exception as e:
            logging.error(f"[{idx}/{total_tickers}] æƒæ {ticker}: âŒ ç™¼ç”ŸéŒ¯èª¤ - {e}")
            continue

    # å ±å‘Šæƒæç¸½çµ
    logging.info(f"æƒæä»»å‹™çµæŸï¼Œå…±ç™¼ç¾ {len(all_signals)} å€‹æ½›åœ¨ä¿¡è™Ÿã€‚")

    # ç”Ÿæˆå ±å‘Šæ–‡æœ¬
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M')
    report = f"ğŸ“Š <b>RunSing</b>-MCB Scanner Report_Bot2.5\n"
    report += f"ğŸ•’ Generated at: {current_time}\n\n"

    if not all_signals:
        report += "â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ˜´ NO SIGNALS FOUND\nâ”â”â”â”â”â”â”â”â”â”â”â”â”\n\nNo entry signals in the last 7 days."
        return report

    all_signals.sort(key=lambda x: x['date'], reverse=True)
    latest_date = all_signals[0]['date']
    latest_group = [s for s in all_signals if s['date'] == latest_date]
    past_group = [s for s in all_signals if s['date'] != latest_date]

    report += "â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ”¥ NEW SIGNAL\nâ”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    for s in latest_group:
        report += f"â€¢ <b>{s['ticker']}</b> â€” {s['action']}\n  Signal Date: {s['date']}\n  Close: ${s['price']:.2f}\n  WT1: {s['mcb_val']:.1f}\n\n"

    if past_group:
        report += "â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ“… PAST SIGNALS\nâ”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        for date, group in groupby(past_group, key=lambda x: x['date']):
            report += f"{date}\n"
            for s in group:
                report += f"â€¢ <b>{s['ticker']}</b> â€” {s['action'].split(' ')[0]} @ ${s['price']:.2f}\n"
            report += "\n"

    report += "â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ¤– æœ¬å ±å‘Šç”± MCB Scanner è‡ªå‹•ç”Ÿæˆï¼Œ\næœ¬ç³»çµ±åƒ…æ•æ‰ã€Œæ©Ÿæœƒå‡ºç¾çš„ç¬é–“ã€ï¼Œæ˜¯å¦åŸ·è¡Œé€²å ´è«‹è‡ªè¡Œåˆ¤æ–·ã€‚"
    return report

# ================= Bot æŒ‡ä»¤è™•ç† =================

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ç”¨æˆ¶é»æ“Šé–‹å§‹æˆ–è¼¸å…¥ /start"""
    log_command(update, "/start") 
    
    user_id = update.effective_chat.id
    users = load_users()
    if user_id not in users:
        users.add(user_id)
        save_users(users)
        
        # --- å›è¦†æ¶ˆæ¯ ---
        await update.message.reply_text(
            "âœ… **è¨‚é–±æˆåŠŸï¼**\næ‚¨å°‡æ¯å¤©æ”¶åˆ° MCB æƒæå ±å‘Šã€‚\n\n"
            "ğŸ‘‰ **ä½¿ç”¨æŒ‡å—ï¼š** è«‹é»æ“Šå·¦ä¸‹è§’èœå–®ï¼Œ\n"
            "æˆ–ç›´æ¥é»æ“Šæˆ–è¼¸å…¥æŒ‡ä»¤ï¼Œå³å¯ä½¿ç”¨ä»¥ä¸‹åŠŸèƒ½ï¼š\n"
            "â€¢ /scan - ç«‹å³æƒæ\n"
            "â€¢ /stop - å–æ¶ˆè¨‚é–±\n"
            "**RunSing-MCB ScanBot 2.5.0 By Joe**", # ç¢ºä¿å…©å€‹æ˜Ÿè™ŸåŒ…è£¹åŠ ç²—æ–‡æœ¬
            parse_mode='Markdown'
        )
        # --- ä¿®è¨‚å¾Œçš„æ­¡è¿è¨Šæ¯çµæŸ ---
        
    else:
        await update.message.reply_text("æ‰‹ç™¢ç™¢ï¼Ÿå†æŒ‰æŠŠä½ æ‹‰é»‘ã€‚é»æ“Š /scan ç«‹å³çµ¦ä½ æƒå€‹æœ€æ–°çš„ã€‚")

async def stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å–æ¶ˆè¨‚é–±"""
    log_command(update, "/stop") 
    
    user_id = update.effective_chat.id
    users = load_users()
    if user_id in users:
        users.remove(user_id)
        save_users(users)
        await update.message.reply_text("âŒ å·²å–æ¶ˆè¨‚é–±ï¼Œå†è¦‹æœ‹å‹")
    else:
        await update.message.reply_text("æ‚¨è¨‚é–±äº†å—ï¼Ÿï¼Ÿï¼Ÿ")

async def scan_now(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æ‰‹å‹•è§¸ç™¼æƒæ (å¸¶å†·å»æ™‚é–“é™åˆ¶)"""
    log_command(update, "/scan") 
    
    user_id = update.effective_chat.id
    current_time = datetime.now()
    
    # æª¢æŸ¥å†·å»æ™‚é–“ (æ¿«ç”¨é™åˆ¶)
    if user_id in LAST_SCAN_TIME:
        time_since_last_scan = current_time - LAST_SCAN_TIME[user_id]
        
        if time_since_last_scan.total_seconds() < SCAN_COOLDOWN_SECONDS:
            remaining_time = SCAN_COOLDOWN_SECONDS - int(time_since_last_scan.total_seconds())
            
            await update.message.reply_text(
                f"ğŸš« **æƒæé »ç‡éé«˜ï¼**\nè«‹ç­‰å¾… `{remaining_time}` ç§’å¾Œå†è©¦ä¸€æ¬¡ï¼Œä»¥ä¿è­·ä¼ºæœå™¨ç©©å®šæ€§ã€‚",
                parse_mode='Markdown'
            )
            return
            
    # é€šéæª¢æŸ¥ï¼Œæ›´æ–°æƒææ™‚é–“ä¸¦é–‹å§‹æƒæ
    LAST_SCAN_TIME[user_id] = current_time
    
    await update.message.reply_text("â³ æ­£åœ¨æƒæç¾è‚¡å¸‚å ´ï¼Œè«‹ç¨å€™ (ç´„éœ€ 30-60 ç§’)...")
    
    # åŸ·è¡Œæƒæä»»å‹™ (è€—æ™‚æ“ä½œ)
    loop = asyncio.get_running_loop()
    report_text = await loop.run_in_executor(None, run_scan_logic)
    
    await update.message.reply_text(report_text, parse_mode='HTML', disable_web_page_preview=True)

# ================= å½©è›‹è™•ç† (æ–°å¢) =================

async def winnie_the_pooh(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å½©è›‹ï¼šç™¼é€ '8964' å›è¦†å°ç†Šç¶­å°¼ç…§ç‰‡"""
    log_command(update, "8964_EGG") 

    try:
        await context.bot.send_photo(
            chat_id=update.effective_chat.id,
            photo=WINNIE_POOH_URL,
            caption="ğŸ¯ æƒ³åƒèœ‚èœœå—ï¼Ÿ",
        )
    except Exception as e:
        await update.message.reply_text("å°ä¸èµ·ï¼Œç¶­å°¼èµ°ä¸Ÿäº†ã€‚")
        logging.error(f"Failed to send Pooh image: {e}")

# ================= æ–°å¢å½©è›‹è™•ç† =================

#async def cat_egg(update: Update, context: ContextTypes.DEFAULT_TYPE):
#    """å½©è›‹ï¼šç™¼é€ '51121' å›è¦†è²“å’ªç›¸é—œè¨Šæ¯"""
#    log_command(update, "51121_EGG")

#    await update.message.reply_text(
#        "ä¾†ä¾†ä¾† æ­å–œä½ æ‰¾åˆ°äº†éš±è—çš„è²“å’ªæŒ‡ä»¤ï¼\n\n"
#        "è‚¡å¸‚å¦‚è²“ï¼Œé›£ä»¥æ‰æ‘¸ï¼Œä½† MCB å¯ä»¥å¹«ä½ 51121å•Š51121ã€‚\n"
#        "https://youtu.be/IxX_QHay02M?si=f7Ep8pELP4iYFce9 \n\n"
#        "åˆ¥51121äº† é¦¬ä¸Šä¸Šå¼·åº¦ï¼š/scan",
#        parse_mode='Markdown',
#        disable_web_page_preview=False 
#    )

# ================= å½©è›‹è™•ç† (ä½¿ç”¨ HTML æ¨¡å¼) =================

async def cat_egg(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å½©è›‹ï¼šç™¼é€ '51121' å›è¦†è²“å’ªç›¸é—œè¨Šæ¯"""
    log_command(update, "51121_EGG")

    # æ³¨æ„ï¼šé€™è£¡ä½¿ç”¨ HTML æ¨™ç±¤ <b>ï¼Œä¸¦è¨­ç½® parse_mode='HTML'
    await update.message.reply_text(
        "ğŸ± <b>å–µå–µï¼</b> ä¾†ä¾†ä¾† æ­å–œä½ æ‰¾åˆ°äº†éš±è—çš„è²“å’ªæŒ‡ä»¤ï¼\n\n"
        "è‚¡å¸‚å¦‚è²“ï¼Œé›£ä»¥æ‰æ‘¸ï¼Œä½† MCB å¯ä»¥å¹«ä½ 51121å•Š51121ã€‚\n"
        f"åˆ¥51121äº† é¦¬ä¸Šä¸Šå¼·åº¦ï¼š/scan\n\nhttps://youtu.be/IxX_QHay02M?si=f7Ep8pELP4iYFce9",
        parse_mode='HTML' # é—œéµï¼šæ”¹ç‚º HTML
    )

    
async def namewee_egg(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å½©è›‹ï¼šç™¼é€ '4896' å›è¦†é»ƒæ˜å¿—æ­Œæ›²é€£çµ"""
    log_command(update, "4896_EGG")
    
    # ç¢ºä¿é–‹å•Ÿç¶²é é è¦½ï¼Œé€™æ¨£ Telegram æœƒé¡¯ç¤º YouTube é è¦½å¡ç‰‡
    await update.message.reply_text(
        "ğŸ¶ **ä½ å«çµ¦äº†åˆ¥äºº åšåˆ¥äººçš„è€å©†ï½**\n\n"
        "æŸ´ç£ åŒ—è§’ éŠ…é‘¼ç£\n"
        "ç£ä»” ä¸­ç’° é‡‘é˜ å°–æ²™å’€\n"
        "æ²¹éº»åœ° æ—ºè§’ å¤ªå­ ä¹é¾å¡˜\n"
        "æ²™ç”° ä¸Šæ°´ ç¾…æ¹– æ·±åœ³ å»£å· å»ˆé–€\n"
        "å°åŒ— ç¦å· å—äº¬ ä¸Šæµ· åŒ—äº¬ ä¸­ç’°... \n\n"
        "https://youtu.be/w-Ol7vb6oCQ?si=IrewkOYwojpqit7x",
        parse_mode='Markdown',
        disable_web_page_preview=False 
    )






        

async def daily_broadcast(context: ContextTypes.DEFAULT_TYPE):
    """æ¯æ—¥è‡ªå‹•å»£æ’­ä»»å‹™"""
    logging.info(f"â° è§¸ç™¼æ¯æ—¥è‡ªå‹•å»£æ’­ä»»å‹™...")
    users = load_users()
    if not users:
        logging.info("æ²’æœ‰è¨‚é–±ç”¨æˆ¶ï¼Œè·³éå»£æ’­ã€‚")
        return

    # åŸ·è¡Œæƒæ
    loop = asyncio.get_running_loop()
    report_text = await loop.run_in_executor(None, run_scan_logic)
    
    # ç™¼é€çµ¦æ‰€æœ‰ç”¨æˆ¶
    for user_id in users:
        try:
            await context.bot.send_message(chat_id=user_id, text=report_text, parse_mode='HTML', disable_web_page_preview=True)
            logging.info(f"å·²ç™¼é€å ±å‘Šçµ¦ç”¨æˆ¶: {user_id}")
        except Exception as e:
            logging.error(f"ç™¼é€çµ¦ {user_id} å¤±æ•—: {e}")

# ================= ä¸»ç¨‹åº =================

if __name__ == '__main__':
    
    # æ§‹å»º Bot
    application = ApplicationBuilder().token(TG_BOT_TOKEN).build()

    # è¨»å†ŠæŒ‡ä»¤
    application.add_handler(CommandHandler('start', start))
    application.add_handler(CommandHandler('scan', scan_now))
    application.add_handler(CommandHandler('stop', stop))
    
    # è¨»å†Šå½©è›‹æŒ‡ä»¤ (MessageHandler)
    # 1. 8964 å½©è›‹
    application.add_handler(MessageHandler(filters.TEXT & filters.Regex('^8964$'), winnie_the_pooh))
    # 2. 51121 å½©è›‹ (æ–°å¢)
    application.add_handler(MessageHandler(filters.TEXT & filters.Regex('^51121$'), cat_egg))
    # 3. 4896 å½©è›‹ (æ–°å¢)
    application.add_handler(MessageHandler(filters.TEXT & filters.Regex('^4896$'), namewee_egg))

    # è¨­ç½®æ¯æ—¥å®šæ™‚ä»»å‹™ (éœ€è¦ JobQueue ä¾è³´)
    job_queue = application.job_queue
    if job_queue:
        # è¨­å®šæ¯å¤©åœ¨å›ºå®šæ™‚é–“é‹è¡Œ (UTC)
        job_queue.run_daily(daily_broadcast, time=DAILY_REPORT_TIME)
    else:
         logging.warning("JobQueue æœªè¨­ç½®ï¼Œæ¯æ—¥å®šæ™‚å ±å‘ŠåŠŸèƒ½å°‡ç„¡æ³•ä½¿ç”¨ã€‚è«‹ç¢ºä¿å·²å®‰è£ 'python-telegram-bot[job-queue]'ã€‚")


    logging.info("ğŸš€ MCB Bot æœå‹™å·²å•Ÿå‹•ï¼")
    print("ğŸš€ MCB Bot æœå‹™å·²å•Ÿå‹•ï¼æŒ‰ Ctrl+C åœæ­¢ã€‚")
    
    # é–‹å§‹è¼ªè©¢ (ä¸€ç›´é‹è¡Œç›´åˆ°æ‰‹å‹•åœæ­¢)
    application.run_polling()
