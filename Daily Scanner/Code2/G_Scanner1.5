import yfinance as yf
import pandas as pd
import numpy as np
import requests
from datetime import datetime
from itertools import groupby

# ================= é…ç½®å€åŸŸ =================
# è‡ªå‹•ç™¼é€TG Report ä½¿ç”¨å…è²»æ•¸æ“š
# Nov/20/2025 10:30 Gemini_1.5
# æƒæè¨ˆç®—æ²’å•é¡Œ UIå¯ä»¥å†å„ªåŒ–ä¸€é»
# 

# 1. Telegram è¨­å®š
TG_BOT_TOKEN = 'ä½ çš„_TG_BOT_TOKEN' 
TG_CHAT_ID = 'ä½ çš„_TG_CHAT_ID'

# 2. è§€å¯Ÿæ¸…å–® (55+ å„ªè³ªæ¨™çš„)
TICKERS = [
    # æŒ‡æ•¸ ETF
    'QQQ', 'SPY', 'DIA', 'IWM', 'SMH', 'VIG', 'XLV', 'XLF',
    # ç§‘æŠ€å·¨é ­
    'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'TSLA', 'META', 'NFLX', 'ADBE', 'CRM', 'ORCL',
    # åŠå°é«”
    'AMD', 'AVGO', 'QCOM', 'TXN', 'INTC', 'MU',
    # æ¶ˆè²»èˆ‡é›¶å”®
    'WMT', 'COST', 'TGT', 'HD', 'LOW', 'MCD', 'SBUX', 'NKE', 'KO', 'PEP', 'PG',
    # é‡‘è
    'JPM', 'BAC', 'V', 'MA', 'AXP', 'BLK', 'GS',
    # é†«ç™‚
    'LLY', 'UNH', 'JNJ', 'ABBV', 'MRK',
    # å·¥æ¥­èƒ½æº
    'CAT', 'XOM', 'CVX',
    # åŠ å¯†æ¦‚å¿µ
    'COIN', 'MSTR'
]

# 3. ç­–ç•¥åƒæ•¸
N1 = 9
N2 = 12
LEVEL_1_BUY = -35  # æ™®é€šè²·å…¥ (-35)
LEVEL_2_BUY = -60  # å¼·åŠ›è²·å…¥ (-60)
LOOKBACK_DAYS = 7  # å›æº¯å¤©æ•¸

# ================= æ ¸å¿ƒé‚è¼¯ =================

def calculate_mcb(df, n1=9, n2=12):
    """è¨ˆç®— MCB æŒ‡æ¨™"""
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.get_level_values(0)

    source = (df['High'] + df['Low'] + df['Close']) / 3
    esa = source.ewm(span=n1, adjust=False).mean()
    d = (source - esa).abs().ewm(span=n1, adjust=False).mean()
    ci = (source - esa) / (0.015 * d.replace(0, 0.00001))
    wt1 = ci.ewm(span=n2, adjust=False).mean()
    wt2 = wt1.rolling(window=4).mean()
    
    df['wt1'] = wt1
    df['wt2'] = wt2
    return df

def scan_history(ticker):
    """æƒæå–®å€‹æ¨™çš„éå» N å¤©çš„ä¿¡è™Ÿ"""
    signals = []
    try:
        df = yf.download(ticker, period="6mo", interval="1d", progress=False, auto_adjust=False)
        
        if len(df) < 50:
            return []

        df = calculate_mcb(df, N1, N2)
        
        check_range = df.iloc[-(LOOKBACK_DAYS + 1):]
        
        for i in range(1, len(check_range)):
            curr_row = check_range.iloc[i]
            prev_row = check_range.iloc[i-1]
            
            # é‡‘å‰åˆ¤æ–·
            crossover = (prev_row['wt1'] < prev_row['wt2']) and (curr_row['wt1'] >= curr_row['wt2'])
            
            if crossover:
                val = curr_row['wt1']
                action_str = ""
                
                if val < LEVEL_2_BUY:
                    action_str = "2X" # å¼·åŠ›è²·å…¥
                elif val < LEVEL_1_BUY:
                    action_str = "1X" # æ™®é€šè²·å…¥
                
                if action_str:
                    signals.append({
                        'ticker': ticker,
                        'date': curr_row.name.strftime('%Y-%m-%d'),
                        'price': curr_row['Close'],
                        'mcb_val': val,
                        'action': action_str
                    })
        return signals

    except Exception as e:
        print(f"Error scanning {ticker}: {e}")
        return []

def send_tg_message(message):
    """ç™¼é€ TG æ¶ˆæ¯"""
    if not TG_BOT_TOKEN or not TG_CHAT_ID:
        print("âš ï¸ TG è¨­å®šæœªå¡«å¯«ï¼Œåƒ…æ‰“å°çµæœ:")
        print(message)
        return

    url = f"https://api.telegram.org/bot{TG_BOT_TOKEN}/sendMessage"
    data = {
        "chat_id": TG_CHAT_ID,
        "text": message,
        "parse_mode": "HTML", 
        "disable_web_page_preview": True
    }
    try:
        requests.post(url, data=data)
    except Exception as e:
        print(f"TG ç™¼é€å¤±æ•—: {e}")

def generate_report(all_signals):
    """ç”Ÿæˆæ¥µç°¡å°ˆæ¥­é¢¨æ ¼å ±å‘Š"""
    
    report = f"ğŸš€ <b>MCB Scan Report</b>\n"
    report += f"Date: {datetime.now().strftime('%Y-%m-%d')} | Targets: {len(TICKERS)}\n"
    report += "======================\n"

    if not all_signals:
        report += "\nNo signals found in the last 7 days.\n"
        report += "Market is neutral/high."
        return report

    # æŒ‰æ—¥æœŸæ’åº (æ–° -> èˆŠ)
    all_signals.sort(key=lambda x: x['date'], reverse=True)
    
    # æŒ‰æ—¥æœŸåˆ†çµ„
    for date, group in groupby(all_signals, key=lambda x: x['date']):
        # æ—¥æœŸæ¨™é¡Œ
        report += f"\nğŸ“… <b>{date}</b>\n"
        report += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
        
        # è©²æ—¥æœŸçš„æ‰€æœ‰ä¿¡è™Ÿ
        for s in group:
            # æ ¼å¼: ä»£ç¢¼  [å€æ•¸]  $åƒ¹æ ¼  (MCBå€¼)
            # ä¾‹å¦‚: MSTR  [2X]  $150.20  (-65.1)
            
            # æ ¹æ“š 1X æˆ– 2X åŠ ç²—é¡¯ç¤ºå€æ•¸
            action_display = f"<b>[{s['action']}]</b>"
            
            line = f"<b>{s['ticker']:<6}</b> {action_display}  ${s['price']:.2f}  ({s['mcb_val']:.1f})\n"
            report += line
        
    report += "\n======================"
    
    return report

# ================= ä¸»ç¨‹åº =================
if __name__ == "__main__":
    print(f"æ­£åœ¨æƒæ {len(TICKERS)} å€‹æ¨™çš„...")
    
    all_signals = []
    
    for ticker in TICKERS:
        sigs = scan_history(ticker)
        if sigs:
            all_signals.extend(sigs)
    
    final_report = generate_report(all_signals)
    send_tg_message(final_report)
    print("âœ… æƒæå®Œæˆï¼Œå ±å‘Šå·²ç™¼é€ã€‚")
