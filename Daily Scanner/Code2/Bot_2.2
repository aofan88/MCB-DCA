import logging
import json
import os
import asyncio
import pytz 
from datetime import datetime, time, timedelta # <-- ç¢ºä¿ datetime å’Œ timedelta å°å…¥

# æ•¸æ“šèˆ‡è¨ˆç®—åº«
import yfinance as yf
import pandas as pd
import numpy as np
from itertools import groupby

# Telegram Bot åº« (v20+)
from telegram import Update
from telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler, JobQueue

# é…ç½®æ—¥èªŒï¼šç¢ºä¿æ‰€æœ‰è¼¸å‡ºéƒ½ä½¿ç”¨æ¨™æº–æ—¥èªŒç³»çµ±
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

# ================= é…ç½®å€åŸŸ =================

# 1. Telegram è¨­å®š
TG_BOT_TOKEN = '8074680946:AAFshgFINNVlVYJFl88-E9z_o8Zj-KsfRSs' 

# 2. æ¯æ—¥è‡ªå‹•æ¨é€æ™‚é–“ (UTCæ™‚é–“)
# ç¾æ±ä¸‹åˆ4é»æ”¶ç›¤ç´„ç‚º UTC 21:00 (å†¬ä»¤æ™‚)ï¼Œè¨­ç½®ç‚º UTC 21:30 ç¢ºä¿æ•¸æ“šæ›´æ–°
DAILY_REPORT_TIME = time(hour=1, minute=00, tzinfo=pytz.utc)

# 3. è§€å¯Ÿæ¸…å–® 
TICKERS = [
    # æŒ‡æ•¸ ETF
    'QQQ', 'SPY', 'DIA', 'IWM', 'SMH', 'VIG', 'XLV', 'XLF',
    # ç§‘æŠ€å·¨é ­
    'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'TSLA', 'META', 'NFLX', 'ADBE', 'CRM', 'ORCL',
    # åŠå°é«”
    'AMD', 'AVGO', 'QCOM', 'TXN', 'INTC', 'MU',
    # æ¶ˆè²»èˆ‡é›¶å”®
    'WMT', 'COST', 'TGT', 'HD', 'LOW', 'MCD', 'SBUX', 'NKE', 'KO', 'PEP', 'PG',
    # é‡‘è
    'JPM', 'BAC', 'V', 'MA', 'AXP', 'BLK', 'GS',
    # é†«ç™‚
    'LLY', 'UNH', 'JNJ', 'ABBV', 'MRK',
    # å·¥æ¥­èƒ½æº
    'CAT', 'XOM', 'CVX',
    # åŠ å¯†æ¦‚å¿µ
    'COIN', 'MSTR'
]

# 4. ç­–ç•¥åƒæ•¸
N1 = 9; N2 = 12
LEVEL_1_BUY = -35
LEVEL_2_BUY = -60
LOOKBACK_DAYS = 7
USER_DATA_FILE = "users.json"

# 5. æ¿«ç”¨é™åˆ¶åƒæ•¸
SCAN_COOLDOWN_SECONDS = 120 # æ¯å€‹ç”¨æˆ¶ç™¼èµ·æƒæçš„é–“éš”æ™‚é–“ (ç§’)

# ================= å…¨å±€è¿½è¹¤è®Šæ•¸ =================
LAST_SCAN_TIME = {} # ç”¨æˆ¶ID: ä¸Šæ¬¡æƒææ™‚é–“ (datetime object)

# ================= åŠ©æ‰‹åŠŸèƒ½ =================

def log_command(update: Update, command: str):
    """å°‡æ¥æ”¶åˆ°çš„æŒ‡ä»¤å’Œç”¨æˆ¶è³‡è¨Šå¯«å…¥æ—¥èªŒ (ç”¨æ–¼è¿½è¹¤å’Œç®¡ç†)"""
    user = update.effective_user
    chat = update.effective_chat
    
    # ç¢ºä¿ç”¨æˆ¶åå­˜åœ¨ï¼Œå¦å‰‡ä½¿ç”¨å…¨å
    username = f"@{user.username}" if user.username else user.full_name
    
    user_info = f"UID:{chat.id} | User: {username}"
    logging.info(f"[COMMAND] {command:<6} received from {user_info}")

def load_users():
    """å¾ JSON è¼‰å…¥è¨‚é–±ç”¨æˆ¶"""
    if not os.path.exists(USER_DATA_FILE): return set()
    try:
        with open(USER_DATA_FILE, 'r') as f:
            return set(json.load(f))
    except json.JSONDecodeError:
        return set()

def save_users(users):
    """å°‡è¨‚é–±ç”¨æˆ¶å„²å­˜åˆ° JSON"""
    with open(USER_DATA_FILE, 'w') as f:
        json.dump(list(users), f)

# ================= æ ¸å¿ƒæƒæé‚è¼¯ =================

def calculate_mcb(df, n1=9, n2=12):
    """è¨ˆç®— MCB æŒ‡æ¨™ (å·²ä¿®å¾© 'false' æ‹¼å¯«éŒ¯èª¤)"""
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.get_level_values(0)
    source = (df['High'] + df['Low'] + df['Close']) / 3
    # æ³¨æ„ï¼šadjust=False å¿…é ˆæ˜¯å¤§å¯« F
    esa = source.ewm(span=n1, adjust=False).mean() 
    d = (source - esa).abs().ewm(span=n1, adjust=False).mean()
    ci = (source - esa) / (0.015 * d.replace(0, 0.00001))
    
    # æ³¨æ„ï¼šadjust=False å¿…é ˆæ˜¯å¤§å¯« F
    wt1 = ci.ewm(span=n2, adjust=False).mean() 
    
    wt2 = wt1.rolling(window=4).mean()
    df['wt1'] = wt1; df['wt2'] = wt2
    return df

def run_scan_logic():
    """åŸ·è¡Œæ‰€æœ‰æ¨™çš„æƒæä¸¦è¿”å›å ±å‘Šæ–‡æœ¬ (å·²å°‡ print æ›¿æ›ç‚º logging)"""
    all_signals = []
    
    logging.info(f"[{datetime.now().strftime('%H:%M:%S')}] é–‹å§‹åŸ·è¡Œæƒæä»»å‹™...")
    
    total_tickers = len(TICKERS) 
    
    for idx, ticker in enumerate(TICKERS, 1):
        try:
            df = yf.download(ticker, period="6mo", interval="1d", progress=False, auto_adjust=False)
            
            if len(df) < 50: 
                logging.warning(f"[{idx}/{total_tickers}] æƒæ {ticker}: æ•¸æ“šä¸è¶³ï¼Œè·³éã€‚")
                continue
                
            df = calculate_mcb(df, N1, N2)
            check_range = df.iloc[-(LOOKBACK_DAYS + 1):]
            
            signal_found = False
            
            for i in range(1, len(check_range)):
                curr_row = check_range.iloc[i]
                prev_row = check_range.iloc[i-1]
                crossover = (prev_row['wt1'] < prev_row['wt2']) and (curr_row['wt1'] >= curr_row['wt2'])
                
                if crossover:
                    val = curr_row['wt1']
                    action_str = ""
                    if val < LEVEL_2_BUY: action_str = "2Ã— Buy"
                    elif val < LEVEL_1_BUY: action_str = "1Ã— Buy"
                    
                    if action_str:
                        all_signals.append({
                            'ticker': ticker,
                            'date': curr_row.name.strftime('%Y-%m-%d'),
                            'price': curr_row['Close'],
                            'mcb_val': val,
                            'action': action_str
                        })
                        signal_found = True
            
            if signal_found:
                 logging.info(f"[{idx}/{total_tickers}] æƒæ {ticker}: âœ… ç™¼ç¾ä¿¡è™Ÿã€‚")
            else:
                 logging.info(f"[{idx}/{total_tickers}] æƒæ {ticker}: ç„¡ä¿¡è™Ÿã€‚")

        except Exception as e:
            # ç™¼ç”ŸéŒ¯èª¤æ™‚è¨˜éŒ„åˆ°æ—¥èªŒ
            logging.error(f"[{idx}/{total_tickers}] æƒæ {ticker}: âŒ ç™¼ç”ŸéŒ¯èª¤ - {e}")
            continue

    # å ±å‘Šæƒæç¸½çµ
    logging.info(f"æƒæä»»å‹™çµæŸï¼Œå…±ç™¼ç¾ {len(all_signals)} å€‹æ½›åœ¨ä¿¡è™Ÿã€‚")

    # ç”Ÿæˆå ±å‘Šæ–‡æœ¬
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M')
    report = f"ğŸ“Š <b>RunSing</b>-MCB Daily Scanner Report_1.6\n"
    report += f"ğŸ•’ Generated at: {current_time}\n\n"

    if not all_signals:
        report += "â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ˜´ NO SIGNALS FOUND\nâ”â”â”â”â”â”â”â”â”â”â”â”â”\n\nNo entry signals in the last 7 days."
        return report

    all_signals.sort(key=lambda x: x['date'], reverse=True)
    latest_date = all_signals[0]['date']
    latest_group = [s for s in all_signals if s['date'] == latest_date]
    past_group = [s for s in all_signals if s['date'] != latest_date]

    report += "â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ”¥ NEW SIGNAL\nâ”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    for s in latest_group:
        report += f"â€¢ <b>{s['ticker']}</b> â€” {s['action']}\n  Signal Date: {s['date']}\n  Close: ${s['price']:.2f}\n  WT1: {s['mcb_val']:.1f}\n\n"

    if past_group:
        report += "â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ“… PAST SIGNALS\nâ”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        for date, group in groupby(past_group, key=lambda x: x['date']):
            report += f"{date}\n"
            for s in group:
                report += f"â€¢ <b>{s['ticker']}</b> â€” {s['action'].split(' ')[0]} @ ${s['price']:.2f}\n"
            report += "\n"

    report += "â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ¤– æœ¬å ±å‘Šç”± MCB Scanner è‡ªå‹•ç”Ÿæˆï¼Œ\næœ¬ç³»çµ±åƒ…æ•æ‰ã€Œæ©Ÿæœƒå‡ºç¾çš„ç¬é–“ã€ï¼Œæ˜¯å¦åŸ·è¡Œé€²å ´è«‹è‡ªè¡Œåˆ¤æ–·ã€‚"
    return report

# ================= Bot æŒ‡ä»¤è™•ç† =================

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ç”¨æˆ¶é»æ“Šé–‹å§‹æˆ–è¼¸å…¥ /start"""
    # ... (log_command é‚è¼¯ä¸è®Š) ...
    
    user_id = update.effective_chat.id
    users = load_users()
    if user_id not in users:
        users.add(user_id)
        save_users(users)
        
        # --- å›è¦†æ¶ˆæ¯ ---
        await update.message.reply_text(
            "âœ… **è¨‚é–±æˆåŠŸï¼**\næ‚¨å°‡æ¯å¤©æ”¶åˆ° MCB æƒæå ±å‘Šã€‚\n\n"
            "ğŸ‘‰ **å¿«æ·éµæç¤ºï¼š** è«‹é»æ“Šå·¦ä¸‹è§’èœå–®ï¼Œ\n"
            "æˆ–ç›´æ¥é»æ“Šæˆ–è¼¸å…¥æŒ‡ä»¤ï¼Œå³å¯ä½¿ç”¨ä»¥ä¸‹åŠŸèƒ½ï¼š\n"
            "â€¢ /scan - ç«‹å³æƒæå¸‚å ´\n"
            "â€¢ /stop - å–æ¶ˆè¨‚é–±\n"
            "**RunSing-MCB ScanBot 2.1 By Joe**", # ç¢ºä¿å…©å€‹æ˜Ÿè™ŸåŒ…è£¹åŠ ç²—æ–‡æœ¬
            parse_mode='Markdown'
        )
        # --- ä¿®è¨‚å¾Œçš„æ­¡è¿è¨Šæ¯çµæŸ ---



# --- ä¿®æ”¹å›è¦†æ¶ˆæ¯å¾é€™è£¡é–‹å§‹ ---
#        await update.message.reply_text(
#            "âœ… è¨‚é–±æˆåŠŸï¼\næ‚¨å°‡æ¯å¤©æ”¶åˆ° MCB æƒæå ±å‘Šã€‚\n\n"
#            "ğŸ‘‰ **å¿«æ·éµæç¤ºï¼š** è«‹é»æ“ŠèŠå¤©è¼¸å…¥æ¡†æ—çš„ **/** ç¬¦è™Ÿï¼Œ\n"
#            "æˆ–ç›´æ¥è¼¸å…¥æŒ‡ä»¤ï¼Œå³å¯ä½¿ç”¨ä»¥ä¸‹åŠŸèƒ½ï¼š\n"
#            "â€¢ /scan - ç«‹å³æƒæå¸‚å ´\n"
#            "â€¢ /stop - å–æ¶ˆè¨‚é–±",
#            parse_mode='Markdown' # ä½¿ç”¨ Markdown è®“æ–‡å­—åŠ ç²—
#        )
        # --- ä¿®æ”¹å›è¦†æ¶ˆæ¯åˆ°é€™è£¡çµæŸ ---
        
    else:
        await update.message.reply_text("æ‰‹ç™¢ç™¢ï¼Ÿå†æŒ‰æŠŠä½ æ‹‰é»‘ã€‚è¼¸å…¥ /scan ç«‹å³çµ¦ä½ æƒå€‹æœ€æ–°çš„ã€‚")

async def stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å–æ¶ˆè¨‚é–±"""
    log_command(update, "/stop") # è¨˜éŒ„æŒ‡ä»¤
    
    user_id = update.effective_chat.id
    users = load_users()
    if user_id in users:
        users.remove(user_id)
        save_users(users)
        await update.message.reply_text("âŒ å·²å–æ¶ˆè¨‚é–±ï¼Œæ‚¨å°‡ä¸å†æ”¶åˆ°æ½¤æ˜‡å ±å‘Šã€‚")
    else:
        await update.message.reply_text("æ‚¨å°šæœªè¨‚é–±ã€‚")

async def scan_now(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æ‰‹å‹•è§¸ç™¼æƒæ (å¸¶å†·å»æ™‚é–“é™åˆ¶)"""
    log_command(update, "/scan") # è¨˜éŒ„æŒ‡ä»¤
    
    user_id = update.effective_chat.id
    current_time = datetime.now()
    
    # æª¢æŸ¥å†·å»æ™‚é–“ (æ¿«ç”¨é™åˆ¶)
    if user_id in LAST_SCAN_TIME:
        time_since_last_scan = current_time - LAST_SCAN_TIME[user_id]
        
        if time_since_last_scan.total_seconds() < SCAN_COOLDOWN_SECONDS:
            remaining_time = SCAN_COOLDOWN_SECONDS - int(time_since_last_scan.total_seconds())
            
            await update.message.reply_text(
                f"ğŸš« **æƒæé »ç‡éé«˜ï¼**\nè«‹ç­‰å¾… `{remaining_time}` ç§’å¾Œå†è©¦ä¸€æ¬¡ï¼Œå†é »ç¹æ“ä½œæŠŠä½ æ‹‰é»‘ã€‚",
                parse_mode='Markdown'
            )
            return
            
    # é€šéæª¢æŸ¥ï¼Œæ›´æ–°æƒææ™‚é–“ä¸¦é–‹å§‹æƒæ
    LAST_SCAN_TIME[user_id] = current_time
    
    await update.message.reply_text("â³ æ­£åœ¨æƒæå¸‚å ´ï¼Œè«‹ç¨å€™ (ç´„éœ€ 30-60 ç§’)...")
    
    # åŸ·è¡Œæƒæä»»å‹™ (è€—æ™‚æ“ä½œ)
    loop = asyncio.get_running_loop()
    report_text = await loop.run_in_executor(None, run_scan_logic)
    
    await update.message.reply_text(report_text, parse_mode='HTML', disable_web_page_preview=True)

async def daily_broadcast(context: ContextTypes.DEFAULT_TYPE):
    """æ¯æ—¥è‡ªå‹•å»£æ’­ä»»å‹™"""
    logging.info(f"â° è§¸ç™¼æ¯æ—¥è‡ªå‹•å»£æ’­ä»»å‹™...")
    users = load_users()
    if not users:
        logging.info("æ²’æœ‰è¨‚é–±ç”¨æˆ¶ï¼Œè·³éå»£æ’­ã€‚")
        return

    # åŸ·è¡Œæƒæ
    loop = asyncio.get_running_loop()
    report_text = await loop.run_in_executor(None, run_scan_logic)
    
    # ç™¼é€çµ¦æ‰€æœ‰ç”¨æˆ¶
    for user_id in users:
        try:
            await context.bot.send_message(chat_id=user_id, text=report_text, parse_mode='HTML', disable_web_page_preview=True)
            logging.info(f"å·²ç™¼é€å ±å‘Šçµ¦ç”¨æˆ¶: {user_id}")
        except Exception as e:
            logging.error(f"ç™¼é€çµ¦ {user_id} å¤±æ•—: {e}")

# ================= ä¸»ç¨‹åº =================

if __name__ == '__main__':
    
    # æ§‹å»º Bot
    application = ApplicationBuilder().token(TG_BOT_TOKEN).build()

    # è¨»å†ŠæŒ‡ä»¤
    application.add_handler(CommandHandler('start', start))
    application.add_handler(CommandHandler('scan', scan_now))
    application.add_handler(CommandHandler('stop', stop))

    # è¨­ç½®æ¯æ—¥å®šæ™‚ä»»å‹™ (éœ€è¦ JobQueue ä¾è³´)
    job_queue = application.job_queue
    if job_queue:
        # è¨­å®šæ¯å¤©åœ¨å›ºå®šæ™‚é–“é‹è¡Œ (UTC)
        job_queue.run_daily(daily_broadcast, time=DAILY_REPORT_TIME)
    else:
         logging.warning("JobQueue æœªè¨­ç½®ï¼Œæ¯æ—¥å®šæ™‚å ±å‘ŠåŠŸèƒ½å°‡ç„¡æ³•ä½¿ç”¨ã€‚è«‹ç¢ºä¿å·²å®‰è£ 'python-telegram-bot[job-queue]'ã€‚")


    logging.info("ğŸš€ MCB Bot æœå‹™å·²å•Ÿå‹•ï¼")
    print("ğŸš€ MCB Bot æœå‹™å·²å•Ÿå‹•ï¼æŒ‰ Ctrl+C åœæ­¢ã€‚")
    
    # é–‹å§‹è¼ªè©¢ (ä¸€ç›´é‹è¡Œç›´åˆ°æ‰‹å‹•åœæ­¢)
    application.run_polling()
