#!/usr/bin/env python3
# MCB Daily Scanner v1.3.2 (EOD-only) 
# 2025-11-14 
# Fixï¼šæ¢å¾©è¶³å¤ æ­·å²ã€é¿å…éŽæ—© dropnaã€æŒ‰å¯¦éš› K æ£’æª¢æŸ¥æœ€è¿‘è¨Šè™Ÿ ä¿®æ­£æ­·å²çª—å£èˆ‡ recent-row ç¯©é¸é‚è¼¯

import os, time, random, json
from datetime import datetime, timedelta
import requests
import pandas as pd
import numpy as np

# ========== CONFIG ==========
EOD_API_KEY = "69169ed4d171d2.32964392"   # â˜… ä½ çš„ EOD API key
#  q79066774 gmail   691549a40cbbd7.99440931
#  888@af888.top   69169ed4d171d2.32964392
#  joe@af888.top   6916c6b0c37948.34099377

USE_EOD = True

TELEGRAM_TOKEN = "8074680946:AAFshgFINNVlVYJFl88-E9z_o8Zj-KsfRSs"
TELEGRAM_CHAT_ID = "6027645130"

# Symbol list (ç¶­æŒä½ å¸¸ç”¨çš„ 50 æª”ï¼Œè«‹ä»¥ EOD å¯æŽ¥å—çš„æ ¼å¼ç‚ºæº–)
STOCK_LIST = [
    "AAPL.US","MSFT.US","NVDA.US","AMZN.US","GOOG.US","META.US",
    "TSLA.US","AVGO.US","JPM.US","BRK-B.US","V.US","MA.US",
    "HD.US","COST.US","WMT.US","MCD.US","KO.US","PEP.US",
    "NFLX.US","AMD.US","QCOM.US","INTC.US","TXN.US",
    "UNH.US","JNJ.US","MRK.US","ABBV.US","PFE.US",
    "XOM.US","CVX.US","COP.US","SLB.US",
    "CAT.US","DE.US","GE.US","UPS.US","FDX.US","BA.US",
    "LOW.US","TGT.US","SBUX.US","NKE.US","ADBE.US",
    "CRM.US","ORCL.US","IBM.US","CSCO.US","AMAT.US"
]

# MCB parameters
CHANNEL_LEN = 9
AVG_LEN = 12
ENTRY1 = -35.0
ENTRY2 = -60.0

# time / output config
LOOKBACK_DAYS = 180       # **é‡è¦**ï¼šæ¢å¾© 180 æˆ–æ›´é•·ï¼Œé¿å…æŒ‡æ¨™æŠ–å‹•
CHECK_WINDOW_DAYS = 7     # æª¢æŸ¥æœ€è¿‘å¤šå°‘å€‹äº¤æ˜“æ—¥ï¼ˆä»¥ K æ£’æ•¸è¨ˆï¼‰
OUT_DIR = os.path.expanduser("~/mcb_signals")
os.makedirs(OUT_DIR, exist_ok=True)

# EOD fetch
EOD_RETRIES = 3
EOD_TIMEOUT = 12

# ========== helper: EODHD fetch ==========
def eodhd_fetch(symbol, from_date, to_date, retries=EOD_RETRIES):
    url = f"https://eodhistoricaldata.com/api/eod/{symbol}"
    params = {
        "from": from_date, "to": to_date,
        "api_token": EOD_API_KEY, "period": "d", "fmt": "json"
    }
    last_err = None
    for attempt in range(1, retries+1):
        try:
            r = requests.get(url, params=params, timeout=EOD_TIMEOUT)
            if r.status_code != 200:
                last_err = f"HTTP {r.status_code}: {r.text[:200]}"
                time.sleep(0.4 + random.random()*0.8)
                continue
            data = r.json()
            if not isinstance(data, list) or len(data) == 0:
                last_err = "Empty JSON or unexpected format"
                time.sleep(0.4 + random.random()*0.8)
                continue
            df = pd.DataFrame(data)
            df.rename(columns={
                "date":"Date","open":"Open","high":"High","low":"Low","close":"Close",
                "adjusted_close":"Adj Close","volume":"Volume"
            }, inplace=True)
            # coerce numeric and parse date
            for c in ["Open","High","Low","Close"]:
                if c in df.columns:
                    df[c] = pd.to_numeric(df[c], errors="coerce")
            df["Date"] = pd.to_datetime(df["Date"], errors="coerce")
            df = df.dropna(subset=["Date","Open","High","Low","Close"])
            df.sort_values("Date", inplace=True)
            df.reset_index(drop=True, inplace=True)
            return df
        except Exception as e:
            last_err = str(e)
            time.sleep(0.4 + random.random()*0.8)
    print(f"[EODHD] {symbol} fetch failed after {retries} attempts: {last_err}")
    return None

# ========== MCB calculation ==========
def compute_mcb(df):
    # expects df sorted by Date ascending
    ap = (df["High"] + df["Low"] + df["Close"]) / 3.0
    esa = ap.ewm(span=CHANNEL_LEN, adjust=False).mean()
    d = (ap - esa).abs().ewm(span=CHANNEL_LEN, adjust=False).mean()
    safeD = d.replace(0, 1e-9)
    ci = (ap - esa) / (0.015 * safeD)
    tci = ci.ewm(span=AVG_LEN, adjust=False).mean()
    df = df.copy()
    df["wt1"] = tci
    df["wt2"] = df["wt1"].rolling(4, min_periods=1).mean()
    return df

# ========== Telegram ==========
def telegram_send(text):
    if not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:
        print("[TG] token/chat_id missing, skip")
        return False
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
        payload = {"chat_id": TELEGRAM_CHAT_ID, "text": text, "parse_mode":"Markdown"}
        r = requests.post(url, data=payload, timeout=10)
        if r.status_code != 200:
            print("[TG] send failed:", r.status_code, r.text[:200])
            return False
        return True
    except Exception as e:
        print("[TG] exception:", e)
        return False

# ========== main scan ==========
def scan_once():
    run_time = datetime.now()
    run_time_str = run_time.strftime("%Y-%m-%d %H:%M")
    today = run_time.date()
    yesterday = today - timedelta(days=1)
    trading_day_str = yesterday.strftime("%Y-%m-%d")

    from_date = (today - timedelta(days=LOOKBACK_DAYS)).strftime("%Y-%m-%d")
    to_date = yesterday.strftime("%Y-%m-%d")

    print(f">>> MCB Scanner run at {run_time_str} (data up to {to_date})")
    all_signals = []

    for sym in STOCK_LIST:
        try:
            df = eodhd_fetch(sym, from_date, to_date)
            if df is None or df.shape[0] < 10:
                print(f"[{sym}] no data or insufficient rows ({None if df is None else df.shape[0]})")
                continue

            df = compute_mcb(df)   # **ä¸è¦åœ¨é€™è£¡ dropna**
            # now drop rows where wt1 is NaN (very early rows)
            df = df.dropna(subset=["wt1"]).reset_index(drop=True)

            # compute signals on full df
            df["cross"] = (df["wt1"].shift(1) < df["wt2"].shift(1)) & (df["wt1"] > df["wt2"])
            df["green_dot"] = df["cross"] & ((df["wt2"] - df["wt1"]) <= 0)
            df["buy1"] = (df["green_dot"] & (df["wt1"] < ENTRY1)).astype(int)
            df["buy2"] = (df["green_dot"] & (df["wt1"] < ENTRY2)).astype(int)

            # we check LAST CHECK_WINDOW_DAYS trading bars (actual rows)
            if df.shape[0] == 0:
                continue
            recent = df.tail(CHECK_WINDOW_DAYS)  # last N trading rows
            # iterate from newest -> oldest or oldest->newest (we'll collect oldest->newest for grouping)
            for _, row in recent.iterrows():
                if int(row.get("buy2", 0)) == 1 or int(row.get("buy1", 0)) == 1:
                    all_signals.append({
                        "symbol": sym,
                        "signal_type": "2x" if int(row.get("buy2", 0)) == 1 else "1x",
                        "signal_date": row["Date"].strftime("%Y-%m-%d"),
                        "price": float(row["Close"]),
                        "wt1": float(row["wt1"])
                    })
        except Exception as e:
            print(f"[ERR] {sym} processing error: {e}")

    # if no signals found
    if not all_signals:
        header = f"ðŸ“Œ MCB Scanner â€” {run_time_str}\n\nLatest trading day used: {trading_day_str}\n\n"
        header += "(No buy signals in the checked window)\n\n"
        header += f"Checked last {CHECK_WINDOW_DAYS} trading bars for {len(STOCK_LIST)} symbols."
        telegram_send(header)
        print("No signals found. Heartbeat sent.")
        # save empty csv for record
        out_file = os.path.join(OUT_DIR, f"signals_{trading_day_str}.csv")
        pd.DataFrame(columns=["symbol","signal_type","signal_date","price","wt1"]).to_csv(out_file, index=False)
        return

    df_out = pd.DataFrame(all_signals)
    df_out = df_out.sort_values(["signal_date","symbol"], ascending=[False, True]).reset_index(drop=True)

    # split yesterday vs past
    df_yesterday = df_out[df_out["signal_date"] == trading_day_str].copy()
    df_past = df_out[df_out["signal_date"] < trading_day_str].copy()

    # save CSV / JSON
    out_file = os.path.join(OUT_DIR, f"signals_{trading_day_str}.csv")
    json_file = os.path.join(OUT_DIR, f"signals_{trading_day_str}.json")
    df_out.to_csv(out_file, index=False, float_format="%.6f")
    with open(json_file, "w") as f:
        json.dump(all_signals, f, indent=2, ensure_ascii=False)

    # Build pretty Telegram text (your preferred format)
    header = f"ðŸ“Œ MCB Scanner â€” {run_time_str}\n\nðŸ—“ Latest trading day used: {trading_day_str} (signals below)\n"
    lines = [header]

    if df_yesterday.empty:
        lines.append("\nï¼ˆNo buy signals yesterdayï¼‰\n")
    else:
        lines.append("\nðŸ”¥ Yesterday's signals (latest trading day):\n")
        # show each with price
        for _, r in df_yesterday.iterrows():
            lines.append(f"â€¢ {r['symbol']} {r['signal_type']} @ ${r['price']:.2f}")

    if not df_past.empty:
        lines.append("\n\nðŸ“… Signals Past Week:\n")
        grouped = df_past.groupby("signal_date")
        dates = sorted(grouped.groups.keys(), reverse=True)
        for d in dates:
            lines.append(f"\nâ€¢ {d}")
            grp = grouped.get_group(d)
            # join items with comma and line breaks for readability
            items = [f"{row['symbol']} {row['signal_type']} @ ${row['price']:.2f}" for _, row in grp.iterrows()]
            # put items each on its own line (or join with comma as you like)
            for it in items:
                lines.append(f"  - {it}")

    text = "\n".join(lines)

    # save summary
    summary_file = os.path.join(OUT_DIR, f"signals_{trading_day_str}_summary.txt")
    with open(summary_file, "w", encoding="utf-8") as f:
        f.write(text)

    sent = telegram_send(text)
    if sent:
        print("TG sent.")
    else:
        print("TG failed.")

    print(f"Saved CSV: {out_file}")
    print(f"Saved JSON: {json_file}")
    print("Done.")

if __name__ == "__main__":
    print("MCB Daily Scanner (EOD-only) starting:", datetime.now().strftime("%Y-%m-%d %H:%M"))
    scan_once()
