#!/usr/bin/env python3
# MCB Daily Scanner v1.3
# Only EOD  Data
# 2025-11-14 ä¿®å¾©ä¸Ÿå¤±å‰å¤©æ•¸æ“š

import os
import time
import random
import json
import requests
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# ========== CONFIG ==========
EOD_API_KEY = "69169ed4d171d2.32964392"   # â˜… EOD API key
USE_EOD = True

TELEGRAM_TOKEN = "8074680946:AAFshgFINNVlVYJFl88-E9z_o8Zj-KsfRSs"
TELEGRAM_CHAT_ID = "6027645130"

# List
STOCK_LIST = [
    "AAPL.US","MSFT.US","NVDA.US","AMZN.US","GOOG.US","META.US",
    "TSLA.US","AVGO.US","JPM.US","BRK-B.US","V.US","MA.US",
    "HD.US","COST.US","WMT.US","MCD.US","KO.US","PEP.US",
    "NFLX.US","AMD.US","QCOM.US","INTC.US","TXN.US",
    "UNH.US","JNJ.US","MRK.US","ABBV.US","PFE.US",
    "XOM.US","CVX.US","COP.US","SLB.US",
    "CAT.US","DE.US","GE.US","UPS.US","FDX.US","BA.US",
    "LOW.US","TGT.US","SBUX.US","NKE.US","ADBE.US",
    "CRM.US","ORCL.US","IBM.US","CSCO.US","AMAT.US"
]

# MCB Config
CHANNEL_LEN = 9
AVG_LEN = 12
ENTRY1 = -35.0   # buy1 é–¾å€¼
ENTRY2 = -60.0   # buy2 é–¾å€¼

# æ™‚é–“èˆ‡è¼¸å‡ºé…ç½®
LOOKBACK_DAYS = 30        # å¾€å›žæŠ“å¤šå°‘æ—¥çš„åŽŸå§‹æ­·å²è³‡æ–™ï¼ˆè¶Šå¤§è¶Šç©©ï¼‰
CHECK_WINDOW_DAYS = 5      # æª¢æŸ¥æœ€è¿‘å¹¾æ—¥å…§æ˜¯å¦å‡ºç¾éŽè¨Šè™Ÿï¼ˆå«æ˜¨å¤©ï¼‰
OUT_DIR = os.path.expanduser("~/mcb_signals")   # å„²å­˜è¼¸å‡ºä½ç½®
os.makedirs(OUT_DIR, exist_ok=True)

# EOD fetch è¨­å®š
EOD_RETRIES = 3
EOD_TIMEOUT = 15  # seconds

# ========== helper: EODHD fetch (retry) ==========
def eodhd_fetch(symbol, from_date, to_date, retries=EOD_RETRIES):
    url = f"https://eodhistoricaldata.com/api/eod/{symbol}"
    params = {
        "from": from_date,
        "to": to_date,
        "api_token": EOD_API_KEY,
        "period": "d",
        "fmt": "json"
    }
    last_err = None
    for attempt in range(1, retries+1):
        try:
            r = requests.get(url, params=params, timeout=EOD_TIMEOUT)
            if r.status_code != 200:
                last_err = f"HTTP {r.status_code} {r.text[:200]}"
                time.sleep(0.5 + random.random()*1.0)
                continue
            data = r.json()
            if not isinstance(data, list) or len(data) == 0:
                last_err = "Empty or invalid JSON"
                time.sleep(0.5 + random.random()*1.0)
                continue
            df = pd.DataFrame(data)
            # standardize columns
            df.rename(columns={
                "date":"Date","open":"Open","high":"High","low":"Low","close":"Close",
                "adjusted_close":"Adj Close","volume":"Volume"
            }, inplace=True)
            # coerce numeric
            for c in ["Open","High","Low","Close"]:
                if c in df.columns:
                    df[c] = pd.to_numeric(df[c], errors="coerce")
            df["Date"] = pd.to_datetime(df["Date"])
            df = df.dropna(subset=["Open","High","Low","Close"])
            df.sort_values("Date", inplace=True)
            df.reset_index(drop=True, inplace=True)
            return df
        except Exception as e:
            last_err = str(e)
            time.sleep(0.5 + random.random()*1.0)
    # all retries failed
    print(f"[EODHD] {symbol} fetch failed after {retries} attempts: {last_err}")
    return None

# ========== MCB computation ==========
def compute_mcb(df):
    ap = (df["High"] + df["Low"] + df["Close"]) / 3.0
    esa = ap.ewm(span=CHANNEL_LEN).mean()
    d = abs(ap - esa).ewm(span=CHANNEL_LEN).mean()
    safeD = d.replace(0, 1e-9)
    ci = (ap - esa) / (0.015 * safeD)
    tci = ci.ewm(span=AVG_LEN).mean()
    df["wt1"] = tci
    df["wt2"] = df["wt1"].rolling(4).mean()
    return df

# ========== Telegram send ==========
def telegram_send(text):
    if not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:
        print("[TG] token/chat_id not set, skip sending.")
        return False
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
        payload = {"chat_id": TELEGRAM_CHAT_ID, "text": text, "parse_mode":"Markdown"}
        r = requests.post(url, data=payload, timeout=10)
        if r.status_code != 200:
            print("[TG] send failed:", r.status_code, r.text[:200])
            return False
        return True
    except Exception as e:
        print("[TG] exception:", e)
        return False

# ========== Main scanner ==========
def scan_once():
    run_time = datetime.now()
    run_time_str = run_time.strftime("%Y-%m-%d %H:%M")
    today = run_time.date()
    yesterday = today - timedelta(days=1)
    trade_date_str = yesterday.strftime("%Y-%m-%d")

    from_dt = today - timedelta(days=LOOKBACK_DAYS)
    from_s = from_dt.strftime("%Y-%m-%d")
    to_s = yesterday.strftime("%Y-%m-%d")  # NOTE: we scan up to yesterday inclusive

    print(f">>> MCB Scanner run at {run_time_str} (using trading day up to {to_s})")
    all_signals = []

    for sym in STOCK_LIST:
        try:
            df = eodhd_fetch(sym, from_s, to_s)
            if df is None:
                # fetch failed, skip symbol
                continue
            df = compute_mcb(df).dropna().reset_index(drop=True)

            # cross / green_dot / buy1 / buy2
            df["cross"] = (df["wt1"].shift(1) < df["wt2"].shift(1)) & (df["wt1"] > df["wt2"])
            df["green_dot"] = df["cross"] & ((df["wt2"] - df["wt1"]) <= 0)
            df["buy1"] = (df["green_dot"] & (df["wt1"] < ENTRY1)).astype(int)
            df["buy2"] = (df["green_dot"] & (df["wt1"] < ENTRY2)).astype(int)

            # window by date (include yesterday and the previous CHECK_WINDOW_DAYS-1 days)
            window_start = yesterday - timedelta(days=CHECK_WINDOW_DAYS-1)
            recent_mask = (df["Date"] >= pd.to_datetime(window_start)) & (df["Date"] <= pd.to_datetime(yesterday))
            recent_df = df.loc[recent_mask].copy()

            if recent_df.empty:
                # no data in the window (maybe symbol has no recent trading), skip
                continue

            # iterate rows in chronological order (oldest -> newest)
            for _, row in recent_df.iterrows():
                if int(row.get("buy2", 0)) == 1 or int(row.get("buy1", 0)) == 1:
                    all_signals.append({
                        "symbol": sym,
                        "signal_type": "2x" if int(row.get("buy2", 0)) == 1 else "1x",
                        "signal_date": row["Date"].strftime("%Y-%m-%d"),
                        "price": float(row["Close"]),
                        "wt1": float(row["wt1"])
                    })
        except Exception as e:
            print(f"[ERR] {sym} processing error: {e}")

    # if no signals found overall
    if not all_signals:
        header = f"ðŸ“Œ MCB Scanner â€” {run_time_str}\n\nLatest trading day used: {trade_date_str}\n\n"
        header += "(No buy signals yesterday)\n\n"
        header += f"Checked last {CHECK_WINDOW_DAYS} trading days (up to {trade_date_str})."
        telegram_send(header)
        print("No signals found. Heartbeat sent.")
        # still save an empty csv for record
        out_file = os.path.join(OUT_DIR, f"signals_{trade_date_str}.csv")
        pd.DataFrame(columns=["symbol","signal_type","signal_date","price","wt1"]).to_csv(out_file, index=False)
        return

    # make dataframe of signals
    df_out = pd.DataFrame(all_signals)
    # sort: newest date first, then symbol
    df_out = df_out.sort_values(["signal_date","symbol"], ascending=[False, True]).reset_index(drop=True)

    # split yesterday vs past
    df_yesterday = df_out[df_out["signal_date"] == trade_date_str].copy()
    df_past = df_out[df_out["signal_date"] < trade_date_str].copy()

    # save CSV and JSON
    out_file = os.path.join(OUT_DIR, f"signals_{trade_date_str}.csv")
    df_out.to_csv(out_file, index=False, float_format="%.6f")
    json_file = os.path.join(OUT_DIR, f"signals_{trade_date_str}.json")
    with open(json_file, "w") as f:
        json.dump(all_signals, f, indent=2)

    # Build Telegram message with exact format you requested
    lines = []
    lines.append(f"ðŸ“Œ **MCB Auto Scanner** â€” {run_time_str}")

    if df_yesterday.empty:
        lines.append("(**NO SIGNALS YESTERDAY**)\n")
    else:
        lines.append("ðŸ”¥ Signals Yesterday:\n")
        for _, r in df_yesterday.iterrows():
            lines.append(f"{r['symbol']} {r['signal_type']} @ ${r['price']:.2f}")
        lines.append("")  # blank line

    # Past signals grouped by date (descending)
    if not df_past.empty:
        lines.append("ðŸ“… **PAST WEEK**\n")
        grouped = df_past.groupby("signal_date")
        # order by date descending:
        dates = sorted(grouped.groups.keys(), reverse=True)
        for d in dates:
            lines.append(f"â€¢ {d}")
            grp = grouped.get_group(d)
            # build list of items for this date
            items = []
            for _, r in grp.iterrows():
                items.append(f"{r['symbol']} {r['signal_type']} @ ${r['price']:.2f}")
            # join items with ', ' and add trailing comma as your format
            for it in items:
                lines.append(f"{it},")
            lines.append("")  # blank line between dates

    text = "\n".join(lines)
    # Save summary text
    summary_file = os.path.join(OUT_DIR, f"signals_{trade_date_str}_summary.txt")
    with open(summary_file, "w") as f:
        f.write(text)

    sent = telegram_send(text)
    if sent:
        print("TG sent.")
    else:
        print("TG failed (check token/chat_id).")

    print(f"Saved CSV: {out_file}")
    print(f"Saved JSON: {json_file}")
    print("Done.")

# ========== Run ==========
if __name__ == "__main__":
    print("MCB Daily Scanner (EOD-only) starting:", datetime.now().strftime("%Y-%m-%d %H:%M"))
    scan_once()
