# ==========================================
# ç³»çµ±ç‰ˆæœ¬: RunSing Capital System v6.3.3 (Critical Fix)
# ç·¨å¯«æ™‚é–“: 2025-12-16
# 
# ä¸»è¦æ”¹å‹•:
# 1. [ç·Šæ€¥ä¿®å¾©] XIRR è¨ˆç®—é‚è¼¯ï¼šåˆªé™¤äº†éŒ¯èª¤çš„ç¸½é¡åˆ¤æ–·ï¼Œä¿®å¾©æ­£æ”¶ç›Šé¡¯ç¤ºç‚º 0 çš„ Bugã€‚
# 2. [å„ªåŒ–] XIRR ç®—æ³•ï¼šæ”¹ç‚ºæª¢æŸ¥è³‡é‡‘æµå‘ (å¿…é ˆæœ‰é€²æœ‰å‡º)ï¼Œç¢ºä¿ brentq æ­£å¸¸æ”¶æ–‚ã€‚
# 3. [ä¿æŒ] v6.3.2 çš„æ‰€æœ‰ä»‹é¢è¨­å®š (Tab1 é¡¯ç¤ºä»½æ•¸/è©•åˆ†, Tab2 é¡¯ç¤ºé‡‘é¡/æˆæœ¬ç·š)ã€‚
# ==========================================

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime, timedelta
from scipy import optimize

# ==========================================
# 0. é é¢é…ç½®
# ==========================================
st.set_page_config(page_title="RunSing | MCB v6.3.3", layout="wide", page_icon="ğŸ¦")

st.title("ğŸ¦ RunSing Capital | MCB æ™ºèƒ½å›¤è‚¡å›æ¸¬ç³»çµ± v6.3.3")
st.markdown("---")

# ==========================================
# 1. å´é‚Šæ¬„ï¼šç­–ç•¥åƒæ•¸
# ==========================================
with st.sidebar:
    st.header("âš™ï¸ ç­–ç•¥æ ¸å¿ƒåƒæ•¸")
    symbol = st.text_input("ä¸»æ¸¬è‚¡ç¥¨ä»£ç¢¼", value="WMT")
    benchmark_symbol = st.text_input("å°æ¨™è³‡ç”¢ (åŒç­–ç•¥ PK)", value="QQQ")
    unit_size = st.number_input("å–®ç­†è²·å…¥é‡‘é¡ ($)", value=1000)
    
    st.divider()
    st.subheader("æŒ‡æ¨™åƒæ•¸")
    wt_ch_len = st.number_input("Channel Length", value=9)
    wt_avg_len = st.number_input("Average Length", value=12)
    key_lvl_1 = st.slider("ä¸€å€è²·å…¥é–¾å€¼", -100, 0, -35)
    key_lvl_2 = st.slider("å…©å€è²·å…¥é–¾å€¼", -100, 0, -60)
    
    st.divider()
    st.caption("Version: 6.3.3 (XIRR Fixed)")

# ==========================================
# 2. è¨ˆç®—æ ¸å¿ƒ & è©•åˆ†ç³»çµ±
# ==========================================
def calculate_xirr(transactions):
    """
    [å·²ä¿®å¾©] ä½¿ç”¨ brentq ç®—æ³•è¨ˆç®— XIRR
    ä¿®å¾©é»ï¼šç§»é™¤äº†éŒ¯èª¤çš„ sum>=0 åˆ¤æ–·ï¼Œæ”¹ç‚ºæª¢æŸ¥æ˜¯å¦æœ‰æ­£è² ç¾é‡‘æµ
    """
    if not transactions or len(transactions) < 2: return 0.0
    
    # æŒ‰æ—¥æœŸæ’åº
    transactions.sort(key=lambda x: x[0])
    dates = [t[0] for t in transactions]
    amounts = [t[1] for t in transactions]
    
    # æ ¸å¿ƒæª¢æŸ¥ï¼šå¿…é ˆæ—¢æœ‰æµå‡º(è²·å…¥è² æ•¸) ä¹Ÿæœ‰æµå…¥(æœ€çµ‚å¸‚å€¼æ­£æ•¸) æ‰èƒ½è¨ˆç®— IRR
    has_pos = any(a > 0 for a in amounts)
    has_neg = any(a < 0 for a in amounts)
    if not (has_pos and has_neg): return 0.0
    
    start_date = dates[0]
    days = [(d - start_date).days for d in dates]
    
    def xnpv(rate):
        # é¿å…é™¤é›¶æˆ–ç„¡çª®å¤§
        if rate <= -1.0: return float('inf')
        return sum([a / ((1 + rate) ** (d / 365.0)) for a, d in zip(amounts, days)])
    
    try:
        # åœ¨ -99.9% åˆ° 10000% ä¹‹é–“å°‹æ‰¾é›¶é»
        return optimize.brentq(xnpv, -0.9999, 100.0, maxiter=100) * 100
    except:
        return 0.0

def calculate_metrics(returns_series, risk_free_rate=0.04):
    """è¨ˆç®—å¤æ™®ã€ç´¢æè«¾ã€æ³¢å‹•ç‡"""
    if len(returns_series) < 2 or returns_series.std() == 0:
        return 0.0, 0.0, 0.0
    volatility = returns_series.std() * np.sqrt(252) * 100
    excess_returns = returns_series - (risk_free_rate / 252)
    sharpe = (excess_returns.mean() / returns_series.std()) * np.sqrt(252)
    
    downside = returns_series[returns_series < 0]
    sortino = (excess_returns.mean() / downside.std()) * np.sqrt(252) if len(downside) > 0 and downside.std() != 0 else 0.0
    return sharpe, sortino, volatility

def calculate_max_drawdown(series):
    """è¨ˆç®—æœ€å¤§å›æ’¤"""
    if len(series) < 1: return 0.0
    s = pd.Series(series)
    if (s <= 0).all(): return 0.0
    running_max = s.cummax()
    drawdown = (s - running_max) / running_max
    return drawdown.min() * 100

def calculate_runsing_score(res):
    """RunSing è³‡ç”¢è©•åˆ†ç³»çµ± (0-100åˆ†)"""
    if not res: return 0
    
    # 1. é€²æ”»åˆ† (XIRR) - æ¬Šé‡ 40 (å¹´åŒ–25%æ»¿åˆ†)
    xirr = res.get('XIRR (%)', 0)
    score_offense = min(40, max(0, (xirr / 25) * 40))
    
    # 2. é˜²å®ˆåˆ† (MaxDD) - æ¬Šé‡ 40 (å›æ’¤0%æ»¿åˆ†, -50%é›¶åˆ†)
    mdd = abs(res.get('Max DD (%)', 0))
    score_defense = max(0, 40 - (mdd / 50 * 40))
    
    # 3. æ•ˆç‡åˆ† (Sharpe/Sortino) - æ¬Šé‡ 20
    score_eff = 0
    sharpe = res.get('Sharpe', 0)
    sortino = res.get('Sortino', 0)
    
    if sharpe >= 1.0: score_eff += 10
    elif sharpe >= 0.5: score_eff += 5
        
    if sortino >= 1.5: score_eff += 10
    elif sortino >= 1.0: score_eff += 5
    
    return int(score_offense + score_defense + score_eff)

@st.cache_data
def get_data(ticker):
    try:
        df = yf.download(ticker, start="1995-01-01", progress=False, auto_adjust=False)
        if df.empty: return None
        if isinstance(df.columns, pd.MultiIndex):
            df.columns = df.columns.get_level_values(0)
        df = df[['Open', 'High', 'Low', 'Close']].copy()
        df = df.ffill().bfill()
        
        ap = (df['High'] + df['Low'] + df['Close']) / 3
        esa = ap.ewm(span=wt_ch_len, adjust=False).mean()
        d = (ap - esa).abs().ewm(span=wt_ch_len, adjust=False).mean()
        ci = (ap - esa) / (0.015 * d)
        wt1 = ci.ewm(span=wt_avg_len, adjust=False).mean()
        wt2 = wt1.rolling(window=3).mean()
        
        df['WT1'] = wt1
        df['WT2'] = wt2
        return df
    except Exception as e:
        return None

def run_simulation(df, start_date, end_date=None):
    start_dt = pd.to_datetime(start_date)
    end_dt = pd.to_datetime(end_date) if end_date else df.index[-1]
    df_test = df[(df.index >= start_dt) & (df.index <= end_dt)].copy()
    if len(df_test) < 10: return None
    df_test['Daily_Ret'] = df_test['Close'].pct_change().fillna(0)
    
    holdings = 0
    total_invested = 0
    total_units = 0
    cash_flows = []
    buy_signals = []
    equity_curve = []
    avg_cost_curve = []
    active_returns = []
    
    for i in range(1, len(df_test) - 1):
        wt1_p = df_test['WT1'].iloc[i-1]
        wt2_p = df_test['WT2'].iloc[i-1]
        wt1_c = df_test['WT1'].iloc[i]
        wt2_c = df_test['WT2'].iloc[i]
        
        crossover = (wt1_p <= wt2_p) and (wt1_c > wt2_c)
        mult = 0
        if crossover:
            if wt1_c <= key_lvl_2: mult = 2
            elif wt1_c <= key_lvl_1: mult = 1
        
        current_date = df_test.index[i+1]
        current_open = df_test['Open'].iloc[i+1]
        current_close = df_test['Close'].iloc[i+1]
        
        if mult > 0:
            cost = unit_size * mult
            shares = cost / current_open
            holdings += shares
            total_invested += cost
            total_units += mult
            
            cash_flows.append((current_date, -cost))
            buy_signals.append({
                'Date': current_date,
                'Price': current_open,
                'Units': mult,
                'Cost': cost
            })
            
        current_value = holdings * current_close
        equity_curve.append(current_value)
        avg_cost = (total_invested / holdings) if holdings > 0 else None
        avg_cost_curve.append(avg_cost)
        
        if holdings > 0:
            active_returns.append(df_test['Daily_Ret'].iloc[i+1])

    last_price = df_test['Close'].iloc[-1]
    final_val = holdings * last_price
    
    if total_invested == 0: return None
    
    # è£œä¸Šæœ€å¾Œä¸€ç­†ç¾é‡‘æµ (å¸‚å€¼) ç”¨æ–¼è¨ˆç®— XIRR
    cash_flows.append((df_test.index[-1], final_val))
    
    res_xirr = calculate_xirr(cash_flows)
    total_profit = final_val - total_invested
    roi = (total_profit / total_invested) * 100
    sharpe, sortino, volatility = calculate_metrics(pd.Series(active_returns))
    max_dd = calculate_max_drawdown(equity_curve)
    
    # DCA å°æ¯”è¨ˆç®—
    monthly_groups = df_test.resample('MS').first()
    dca_roi = 0.0
    if len(monthly_groups) > 0:
        monthly_amt = total_invested / len(monthly_groups)
        dca_shares = 0
        dca_inv = 0
        for _, row in monthly_groups.iterrows():
            if pd.isna(row['Open']): continue
            dca_shares += monthly_amt / row['Open']
            dca_inv += monthly_amt
        dca_final = dca_shares * last_price
        dca_roi = ((dca_final - dca_inv) / dca_inv * 100) if dca_inv > 0 else 0.0

    return {
        "Period": f"{start_dt.strftime('%Y-%m')} ~ {end_dt.strftime('%Y-%m')}",
        "Invested": total_invested,
        "Final Value": final_val,
        "Profit": total_profit,
        "ROI (%)": roi,
        "DCA ROI (%)": dca_roi,
        "XIRR (%)": res_xirr,
        "Max DD (%)": max_dd,
        "Sharpe": sharpe,
        "Sortino": sortino,
        "Volatility (%)": volatility,
        "Total Units": total_units,
        "Buy Signals": buy_signals,
        "DataFrame": df_test,
        "Avg Cost Curve": avg_cost_curve
    }

# ==========================================
# 3. åŠ‡æœ¬å®šç¾©
# ==========================================
SCENARIOS = [
    {"name": "ğŸ“š æ­·å²å…¨é€±æœŸ", "start": "1995-01-01", "end": datetime.now().strftime('%Y-%m-%d')},
    {"name": "ğŸ“‰ äº’è¯ç¶²æ³¡æ²«", "start": "2000-03-24", "end": "2002-10-09"},
    {"name": "ğŸŒŠ é‡‘èæµ·å˜¯", "start": "2007-10-01", "end": "2009-03-09"},
    {"name": "ğŸ¢ ç¾è‚¡å¤±è½åå¹´", "start": "2000-01-01", "end": "2013-01-01"},
    {"name": "ğŸ˜´ 2015-2016 ç›¤æ•´", "start": "2015-01-01", "end": "2016-12-31"},
    {"name": "ğŸ¦  æ–°å† ç†”æ–· Vè½‰", "start": "2020-02-01", "end": "2020-08-31"},
    {"name": "ğŸš€ 2021è‡³ä»Š", "start": "2021-01-01", "end": datetime.now().strftime('%Y-%m-%d')},
]

# ==========================================
# 4. ä¸»ç¨‹å¼é‚è¼¯
# ==========================================
full_df = get_data(symbol)
bench_df = get_data(benchmark_symbol) if benchmark_symbol else None

if full_df is not None:
    
    tab1, tab2 = st.tabs(["ğŸ“Š æ­·å²é€±æœŸè©•åˆ† (Overview)", "ğŸ› ï¸ è‡ªå®šç¾©è©³ç´°å›æ¸¬ (Deep Dive)"])
    
    # ==================================================
    # TAB 1: æ­·å²é€±æœŸå ±å‘Š (å«è©•åˆ†ç³»çµ±)
    # ==================================================
    with tab1:
        st.subheader(f"ğŸ“ {symbol} è³‡ç”¢é«”æª¢èˆ‡è©•åˆ†å ±å‘Š")
        st.caption(f"RS è©•åˆ†èªªæ˜ï¼šç¶œåˆè€ƒæ…®ã€XIRR (é€²æ”»)ã€ã€ã€æœ€å¤§å›æ’¤ (é˜²å®ˆ)ã€èˆ‡ã€å¤æ™®æ¯”ç‡ (æ•ˆç‡)ã€ã€‚æ»¿åˆ†100ï¼Œ80åˆ†ä»¥ä¸Šç‚ºå„ªè³ªè³‡ç”¢ã€‚")
        
        # å¯é¸æ¬„ä½ (Tab 1 ç§»é™¤ã€Œç¸½æŠ•å…¥ã€)
        all_cols = ["ç´¯è¨ˆä»½æ•¸", "ROI (%)", "å°æ¨™ ROI", "DCA ROI (%)", "XIRR (%)", "æœ€å¤§å›æ’¤", "å¤æ™®", "ç´¢æè«¾", "æ³¢å‹•ç‡"]
        default_cols = ["ç´¯è¨ˆä»½æ•¸", "ROI (%)", "å°æ¨™ ROI", "DCA ROI (%)", "XIRR (%)", "æœ€å¤§å›æ’¤", "å¤æ™®", "ç´¢æè«¾", "æ³¢å‹•ç‡"]
        selected_cols = st.multiselect("é¸æ“‡å±•ç¤ºæ•¸æ“š:", all_cols, default=default_cols)
        
        results_list = []
        my_bar = st.progress(0)
        
        for idx, sc in enumerate(SCENARIOS):
            res_main = run_simulation(full_df, sc["start"], sc["end"])
            res_bench = None
            if bench_df is not None:
                res_bench = run_simulation(bench_df, sc["start"], sc["end"])

            if res_main:
                # è¨ˆç®—è©•åˆ†
                rs_score = calculate_runsing_score(res_main)
                bench_roi_str = f"{res_bench['ROI (%)']:.1f}%" if res_bench else "N/A"
                
                # å»ºæ§‹åŸºç¤æ•¸æ“š
                row_data = {
                    "åŠ‡æœ¬å ´æ™¯": sc["name"],
                    "æ™‚é–“ç¯„åœ": res_main["Period"],
                    "RS è©•åˆ†": rs_score,
                }
                
                # å»ºæ§‹å¯é¸æ•¸æ“š
                raw_data = {
                    "ç´¯è¨ˆä»½æ•¸": res_main['Total Units'],
                    "ROI (%)": f"{res_main['ROI (%)']:.1f}%",
                    "å°æ¨™ ROI": bench_roi_str,
                    "DCA ROI (%)": f"{res_main['DCA ROI (%)']:.1f}%",
                    "XIRR (%)": f"{res_main['XIRR (%)']:.2f}%",
                    "æœ€å¤§å›æ’¤": f"{res_main['Max DD (%)']:.2f}%",
                    "å¤æ™®": f"{res_main['Sharpe']:.2f}",
                    "ç´¢æè«¾": f"{res_main['Sortino']:.2f}",
                    "æ³¢å‹•ç‡": f"{res_main['Volatility (%)']:.1f}%"
                }
                
                # åªåŠ å…¥ä½¿ç”¨è€…é¸çš„
                for col in selected_cols:
                    row_data[col] = raw_data[col]
                
                results_list.append(row_data)
                
            my_bar.progress((idx + 1) / len(SCENARIOS))
        my_bar.empty()
        
        if results_list:
            df_res = pd.DataFrame(results_list)
            # è®“ RS è©•åˆ†æ’åœ¨å‰é¢
            cols_order = ["åŠ‡æœ¬å ´æ™¯", "æ™‚é–“ç¯„åœ", "RS è©•åˆ†"] + [c for c in selected_cols]
            st.dataframe(df_res[cols_order], use_container_width=True, height=500)

    # ==================================================
    # TAB 2: è‡ªå®šç¾©è©³ç´°å›æ¸¬
    # ==================================================
    with tab2:
        col_ctrl, col_chart = st.columns([1, 4])
        
        with col_ctrl:
            st.markdown("### â³ æ™‚é–“èˆ‡è¨­ç½®")
            min_date = full_df.index[0].date()
            max_date = full_df.index[-1].date()
            default_start = max(min_date, datetime.now().date() - timedelta(days=365*5))
            
            start_input = st.date_input("é–‹å§‹æ—¥æœŸ", value=default_start, min_value=min_date, max_value=max_date)
            end_input = st.date_input("çµæŸæ—¥æœŸ", value=max_date, min_value=min_date, max_value=max_date)
            
            st.divider()
            st.markdown("### ğŸ¨ åœ–è¡¨é¸é …")
            show_cost = st.checkbox("é¡¯ç¤ºå¹³å‡æˆæœ¬ç·š", value=True)
            log_scale = st.checkbox("ä½¿ç”¨å°æ•¸åæ¨™ (Log)", value=False)
            
            sim_res = None
            bench_res = None
            if start_input < end_input:
                sim_res = run_simulation(full_df, start_input, end_input)
                if bench_df is not None:
                    bench_res = run_simulation(bench_df, start_input, end_input)

        with col_chart:
            if sim_res:
                df_period = sim_res['DataFrame']
                
                # è¨ˆç®—è©²é€±æœŸçš„è©•åˆ†
                period_score = calculate_runsing_score(sim_res)

                # 1. å„€è¡¨æ¿ (Tab 2 ç§»é™¤ã€Œç´¯è¨ˆä»½æ•¸ã€)
                st.markdown(f"#### ğŸ“Š ç­–ç•¥æ·±åº¦é¢æ¿ (æœ¬é€±æœŸ RS è©•åˆ†: :red[{period_score} åˆ†])")
                
                m1, m2, m3, m4 = st.columns(4)
                m1.metric("ğŸ’° ç¸½æŠ•å…¥æœ¬é‡‘", f"${sim_res['Invested']:,.0f}")
                m2.metric("ğŸ’µ æœ€çµ‚è³‡ç”¢å¸‚å€¼", f"${sim_res['Final Value']:,.0f}", delta=f"${sim_res['Profit']:,.0f}")
                m3.metric("ğŸš€ ç­–ç•¥ ROI", f"{sim_res['ROI (%)']:.1f}%")
                m4.metric("ğŸ›¡ï¸ å¹³å‡æŒå€‰æˆæœ¬", f"${sim_res['Avg Cost Curve'][-1]:.2f}")

                r1, r2, r3, r4 = st.columns(4)
                r1.metric("ğŸ“… XIRR (çœŸå¯¦å¹´åŒ–)", f"{sim_res['XIRR (%)']:.2f}%")
                r2.metric("ğŸ“‰ æœ€å¤§å›æ’¤", f"-{sim_res['Max DD (%)']:.2f}%")
                dca_gap = sim_res['ROI (%)'] - sim_res['DCA ROI (%)']
                r3.metric("ğŸ†š å®šæŠ• (DCA) å·®è·", f"{sim_res['DCA ROI (%)']:.1f}%", delta=f"{dca_gap:.1f}%")
                r4.metric("ğŸ² äº¤æ˜“æ¬¡æ•¸", f"{len(sim_res['Buy Signals'])}")

                st.divider()

                # 2. å°æ¨™æ•¸æ“šå€
                if bench_res:
                    st.caption(f"ğŸ’¡ å°æ¨™åƒè€ƒ: {benchmark_symbol}")
                    b1, b2, b3, b4 = st.columns(4)
                    diff_roi = sim_res['ROI (%)'] - bench_res['ROI (%)']
                    b1.metric(f"{benchmark_symbol} ROI", f"{bench_res['ROI (%)']:.1f}%", delta=f"{diff_roi:.1f}% (Alpha)")
                    b2.metric(f"{benchmark_symbol} XIRR", f"{bench_res['XIRR (%)']:.2f}%")
                    b3.metric(f"{benchmark_symbol} Max DD", f"-{bench_res['Max DD (%)']:.2f}%")
                    b4.metric(f"{benchmark_symbol} Sharpe", f"{bench_res['Sharpe']:.2f}")

                # 3. åœ–è¡¨
                fig = make_subplots(specs=[[{"secondary_y": True}]])

                # ä¸»è³‡ç”¢
                fig.add_trace(go.Scatter(
                    x=df_period.index, y=df_period['Close'],
                    mode='lines', name=f'{symbol} è‚¡åƒ¹',
                    line=dict(color='#bdc3c7', width=1)
                ), secondary_y=False)

                # æˆæœ¬ç·š
                if show_cost:
                    fig.add_trace(go.Scatter(
                        x=df_period.index[1:], y=sim_res['Avg Cost Curve'],
                        mode='lines', name='æ‚¨çš„æŒå€‰æˆæœ¬',
                        line=dict(color='#f39c12', width=2, dash='dash')
                    ), secondary_y=False)

                # è²·é»
                buys = sim_res['Buy Signals']
                if buys:
                    b_dates = [b['Date'] for b in buys]
                    b_prices = [b['Price'] for b in buys]
                    fig.add_trace(go.Scatter(
                        x=b_dates, y=b_prices,
                        mode='markers', name='ç­–ç•¥è²·å…¥',
                        marker=dict(symbol='triangle-up', size=10, color='#00CC96', line=dict(width=1, color='white')),
                        text=[f"è²·å…¥{b['Units']}ä»½" for b in buys]
                    ), secondary_y=False)

                # å°æ¨™è³‡ç”¢
                if bench_res:
                    df_bench = bench_res['DataFrame']
                    fig.add_trace(go.Scatter(
                        x=df_bench.index, y=df_bench['Close'],
                        mode='lines', name=f'{benchmark_symbol} (åŒç­–ç•¥)',
                        line=dict(color='#9b59b6', width=1.5, dash='dot')
                    ), secondary_y=True)

                fig.update_layout(
                    title=f"ç­–ç•¥å¯è¦–åŒ–: {start_input} ~ {end_input}",
                    height=600,
                    template="plotly_dark",
                    hovermode="x unified",
                    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
                    margin=dict(l=10, r=10, t=50, b=10)
                )
                
                y_type = "log" if log_scale else "linear"
                fig.update_yaxes(title_text=f"{symbol} åƒ¹æ ¼", type=y_type, secondary_y=False)
                fig.update_yaxes(title_text=f"{benchmark_symbol} åƒ¹æ ¼", type=y_type, secondary_y=True, showgrid=False)

                st.plotly_chart(fig, use_container_width=True)
                
                with st.expander("æŸ¥çœ‹è©³ç´°äº¤æ˜“è¨˜éŒ„"):
                    st.dataframe(pd.DataFrame(buys), use_container_width=True)

            else:
                st.warning("âš ï¸ è©²å€é–“å…§ç„¡æ•¸æ“šæˆ–ä¸è¶³ä»¥é€²è¡Œå›æ¸¬ï¼Œè«‹èª¿æ•´æ—¥æœŸã€‚")
